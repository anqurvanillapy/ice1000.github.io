---
layout: post
title: First-class cases in MLPolyR
category: PLT
tags: MLPolyR, first-class cases
keywords: Type Systems
description: The design of the MLPolyR language
katex: true
---

Recently I've found a very interesting programming language named *MLPolyR*,
which is (kind-of) a dialect of Standard ML and it's implemented in Standard ML.
The original implementation is bootstrapped using SML/NJ and uses
Power PC assembly code as its backend so it's very difficult to run the examples.

Fortunately, the type checker still works platform-independently.
@LdBeth (together with me) had made some effort to make it compile with MLton
and have created a [GitHub repo](https://github.com/owo-lang/MLPolyR)
so it's now accessible from everywhere.

*MLPolyR* is interesting because of its type system.
It's very similar to Vanilla Haskell (I'm not saying System F due to the presence of
sum types and record types), but extended with first-class sums and records
and support polymorphic operations on them using row-polymorphism.

(Labeled) sum types, aka coproducts, are disjoint unions of types.
Constructing an instance of a coproduct requires invoking one of the constructors,
while destructing (in other words, "using") such an instance demands handlers of all
possible constructors.
Dually, (labeled) record types, aka products, are Cartesian products of types.
Constructing an instance of a product requires all the record fields' values,
while destructing such an instance only demands on destructor (and you get the record
field value).

This duality is beautiful -- it means works on records can be migrated to
sums with little work (and vise versa).


