---
layout: post
title: Membership proofs and De Bruijn indices
category: PLT
tags: PLT Agda
keywords: PLT
agda: true
description: Membership proofs and De Bruijn indices
---

<pre class="Agda"><a id="181" class="Symbol">{-#</a> <a id="185" class="Keyword">OPTIONS</a> <a id="193" class="Pragma">--cubical</a> <a id="203" class="Symbol">#-}</a>
<a id="207" class="Keyword">module</a> <a id="214" href="" class="Module">2020-1-19-DeBruijnIndex</a> <a id="238" class="Keyword">where</a>

<a id="245" class="Keyword">open</a> <a id="250" class="Keyword">import</a> <a id="257" href="/lagda/Cubical.Data.Bool.html" class="Module">Cubical.Data.Bool</a>
<a id="275" class="Keyword">open</a> <a id="280" class="Keyword">import</a> <a id="287" href="/lagda/Cubical.Data.List.html" class="Module">Cubical.Data.List</a>
<a id="305" class="Keyword">open</a> <a id="310" class="Keyword">import</a> <a id="317" href="/lagda/Cubical.Data.Maybe.html" class="Module">Cubical.Data.Maybe</a>
<a id="336" class="Keyword">open</a> <a id="341" class="Keyword">import</a> <a id="348" href="/lagda/Cubical.Data.Prod.html" class="Module">Cubical.Data.Prod</a>
<a id="366" class="Keyword">open</a> <a id="371" class="Keyword">import</a> <a id="378" href="/lagda/Cubical.Data.Sigma.html" class="Module">Cubical.Data.Sigma</a> <a id="397" class="Keyword">hiding</a> <a id="404" class="Symbol">(</a><a id="405" href="/lagda/Agda.Builtin.Cubical.Path.html#381" class="Function Operator">_≡_</a><a id="408" class="Symbol">)</a>
<a id="410" class="Keyword">open</a> <a id="415" class="Keyword">import</a> <a id="422" href="/lagda/Cubical.Foundations.Function.html" class="Module">Cubical.Foundations.Function</a>
<a id="451" class="Keyword">open</a> <a id="456" class="Keyword">import</a> <a id="463" href="/lagda/Cubical.Relation.Nullary.html" class="Module">Cubical.Relation.Nullary</a>

<a id="489" class="Keyword">open</a> <a id="494" class="Keyword">import</a> <a id="501" href="/lagda/Agda.Builtin.Equality.html" class="Module">Agda.Builtin.Equality</a>
<a id="523" class="Keyword">open</a> <a id="528" class="Keyword">import</a> <a id="535" href="/lagda/Agda.Builtin.Nat.html" class="Module">Agda.Builtin.Nat</a>
<a id="552" class="Keyword">open</a> <a id="557" class="Keyword">import</a> <a id="564" href="/lagda/Agda.Builtin.String.html" class="Module">Agda.Builtin.String</a>

<a id="585" class="Keyword">variable</a> <a id="594" href="#594" class="Generalizable">A</a> <a id="596" class="Symbol">:</a> <a id="598" class="PrimitiveType">Set</a>
</pre>
This post requires basic knowledge on dependent type programming,
in the sense that Idris people would prefer.
Though I imported cubical libraries, I didn't mean to use the cubical features they provide.
I just need a working list definition and basic operations on an equality type.

# The "contains" relation

In a dependent type setting, we can define propositions as types.
Like, the "contains" relation is a type:

<pre class="Agda"><a id="1035" class="Keyword">infix</a> <a id="1041" class="Number">4</a> <a id="1043" href="#1052" class="Datatype Operator">_∈_</a>
<a id="1047" class="Keyword">data</a> <a id="_∈_"></a><a id="1052" href="#1052" class="Datatype Operator">_∈_</a> <a id="1056" class="Symbol">{</a><a id="1057" href="#1057" class="Bound">A</a> <a id="1059" class="Symbol">:</a> <a id="1061" class="PrimitiveType">Set</a><a id="1064" class="Symbol">}</a> <a id="1066" class="Symbol">(</a><a id="1067" href="#1067" class="Bound">a</a> <a id="1069" class="Symbol">:</a> <a id="1071" href="#1057" class="Bound">A</a><a id="1072" class="Symbol">)</a> <a id="1074" class="Symbol">:</a> <a id="1076" href="/lagda/Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1081" href="#1057" class="Bound">A</a> <a id="1083" class="Symbol">-&gt;</a> <a id="1086" class="PrimitiveType">Set</a> <a id="1090" class="Keyword">where</a>
  <a id="_∈_.here"></a><a id="1098" href="#1098" class="InductiveConstructor">here</a>  <a id="1104" class="Symbol">:</a> <a id="1106" class="Symbol">(</a><a id="1107" href="#1107" class="Bound">as</a> <a id="1110" class="Symbol">:</a> <a id="1112" href="/lagda/Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1117" href="#1057" class="Bound">A</a><a id="1118" class="Symbol">)</a> <a id="1120" class="Symbol">-&gt;</a> <a id="1123" href="#1067" class="Bound">a</a> <a id="1125" href="#1052" class="Datatype Operator">∈</a> <a id="1127" href="#1067" class="Bound">a</a> <a id="1129" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1131" href="#1107" class="Bound">as</a>
  <a id="_∈_.there"></a><a id="1136" href="#1136" class="InductiveConstructor">there</a> <a id="1142" class="Symbol">:</a> <a id="1144" class="Symbol">∀</a> <a id="1146" class="Symbol">{</a><a id="1147" href="#1147" class="Bound">as</a> <a id="1150" href="#1150" class="Bound">c</a><a id="1151" class="Symbol">}</a> <a id="1153" class="Symbol">-&gt;</a> <a id="1156" class="Symbol">(</a><a id="1157" href="#1067" class="Bound">a</a> <a id="1159" href="#1052" class="Datatype Operator">∈</a> <a id="1161" href="#1147" class="Bound">as</a><a id="1163" class="Symbol">)</a> <a id="1165" class="Symbol">-&gt;</a> <a id="1168" href="#1067" class="Bound">a</a> <a id="1170" href="#1052" class="Datatype Operator">∈</a> <a id="1172" href="#1150" class="Bound">c</a> <a id="1174" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1176" href="#1147" class="Bound">as</a>
</pre>
We can observe some trivial "contains" facts:

<pre class="Agda"><a id="1239" href="#1239" class="Function">_</a> <a id="1241" class="Symbol">:</a> <a id="1243" class="Number">1</a> <a id="1245" href="#1052" class="Datatype Operator">∈</a> <a id="1247" class="Number">1</a> <a id="1249" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1251" class="Number">3</a> <a id="1253" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1255" href="/lagda/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
<a id="1258" class="Symbol">_</a> <a id="1260" class="Symbol">=</a> <a id="1262" href="#1098" class="InductiveConstructor">here</a> <a id="1267" class="Symbol">(</a><a id="1268" class="Number">3</a> <a id="1270" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1272" href="/lagda/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="1274" class="Symbol">)</a>

<a id="1277" href="#1277" class="Function">_</a> <a id="1279" class="Symbol">:</a> <a id="1281" class="Number">1</a> <a id="1283" href="#1052" class="Datatype Operator">∈</a> <a id="1285" class="Number">2</a> <a id="1287" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1289" class="Number">1</a> <a id="1291" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1293" href="/lagda/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
<a id="1296" class="Symbol">_</a> <a id="1298" class="Symbol">=</a> <a id="1300" href="#1136" class="InductiveConstructor">there</a> <a id="1306" class="Symbol">(</a><a id="1307" href="#1098" class="InductiveConstructor">here</a> <a id="1312" href="/lagda/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="1314" class="Symbol">)</a>

<a id="1317" href="#1317" class="Function">_</a> <a id="1319" class="Symbol">:</a> <a id="1321" class="Number">1</a> <a id="1323" href="#1052" class="Datatype Operator">∈</a> <a id="1325" class="Number">2</a> <a id="1327" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1329" class="Number">1</a> <a id="1331" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1333" class="Number">3</a> <a id="1335" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1337" href="/lagda/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
<a id="1340" class="Symbol">_</a> <a id="1342" class="Symbol">=</a> <a id="1344" href="#1136" class="InductiveConstructor">there</a> <a id="1350" class="Symbol">(</a><a id="1351" href="#1098" class="InductiveConstructor">here</a> <a id="1356" class="Symbol">(</a><a id="1357" class="Number">3</a> <a id="1359" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1361" href="/lagda/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="1363" class="Symbol">))</a>
</pre>
We can see that `here` is the proof that a list contains its head,
and `there` is the proof that if a list contains something, appending anything
to the list head will still make the appended list contain the thing.
We can generalize `there` to list concatenation:

<pre class="Agda"><a id="theres"></a><a id="1645" href="#1645" class="Function">theres</a> <a id="1652" class="Symbol">:</a> <a id="1654" class="Symbol">∀</a> <a id="1656" class="Symbol">{</a><a id="1657" href="#1657" class="Bound">as</a> <a id="1660" href="#1660" class="Bound">bs</a> <a id="1663" class="Symbol">:</a> <a id="1665" href="/lagda/Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1670" href="#594" class="Generalizable">A</a><a id="1671" class="Symbol">}</a> <a id="1673" class="Symbol">{</a><a id="1674" href="#1674" class="Bound">a</a><a id="1675" class="Symbol">}</a> <a id="1677" class="Symbol">-&gt;</a> <a id="1680" href="#1674" class="Bound">a</a> <a id="1682" href="#1052" class="Datatype Operator">∈</a> <a id="1684" href="#1660" class="Bound">bs</a> <a id="1687" class="Symbol">-&gt;</a> <a id="1690" href="#1674" class="Bound">a</a> <a id="1692" href="#1052" class="Datatype Operator">∈</a> <a id="1694" class="Symbol">(</a><a id="1695" href="#1657" class="Bound">as</a> <a id="1698" href="/lagda/Cubical.Data.List.Base.html#275" class="Function Operator">++</a> <a id="1701" href="#1660" class="Bound">bs</a><a id="1703" class="Symbol">)</a>
<a id="1705" href="#1645" class="Function">theres</a> <a id="1712" class="Symbol">{</a><a id="1713" class="Argument">as</a> <a id="1716" class="Symbol">=</a> <a id="1718" href="/lagda/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="1720" class="Symbol">}</a> <a id="1722" href="#1722" class="Bound">p</a> <a id="1724" class="Symbol">=</a> <a id="1726" href="#1722" class="Bound">p</a>
<a id="1728" href="#1645" class="Function">theres</a> <a id="1735" class="Symbol">{</a><a id="1736" class="Argument">as</a> <a id="1739" class="Symbol">=</a> <a id="1741" class="Symbol">_</a> <a id="1743" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1745" class="Symbol">_}</a> <a id="1748" href="#1748" class="Bound">p</a> <a id="1750" class="Symbol">=</a> <a id="1752" href="#1136" class="InductiveConstructor">there</a> <a id="1758" class="Symbol">(</a><a id="1759" href="#1645" class="Function">theres</a> <a id="1766" href="#1748" class="Bound">p</a><a id="1767" class="Symbol">)</a>

<a id="theres′"></a><a id="1770" href="#1770" class="Function">theres′</a> <a id="1778" class="Symbol">:</a> <a id="1780" class="Symbol">∀</a> <a id="1782" class="Symbol">{</a><a id="1783" href="#1783" class="Bound">as</a> <a id="1786" href="#1786" class="Bound">bs</a> <a id="1789" class="Symbol">:</a> <a id="1791" href="/lagda/Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1796" href="#594" class="Generalizable">A</a><a id="1797" class="Symbol">}</a> <a id="1799" class="Symbol">{</a><a id="1800" href="#1800" class="Bound">a</a><a id="1801" class="Symbol">}</a> <a id="1803" class="Symbol">-&gt;</a> <a id="1806" href="#1800" class="Bound">a</a> <a id="1808" href="#1052" class="Datatype Operator">∈</a> <a id="1810" href="#1783" class="Bound">as</a> <a id="1813" class="Symbol">-&gt;</a> <a id="1816" href="#1800" class="Bound">a</a> <a id="1818" href="#1052" class="Datatype Operator">∈</a> <a id="1820" class="Symbol">(</a><a id="1821" href="#1783" class="Bound">as</a> <a id="1824" href="/lagda/Cubical.Data.List.Base.html#275" class="Function Operator">++</a> <a id="1827" href="#1786" class="Bound">bs</a><a id="1829" class="Symbol">)</a>
<a id="1831" href="#1770" class="Function">theres′</a> <a id="1839" class="Symbol">(</a><a id="1840" href="#1098" class="InductiveConstructor">here</a> <a id="1845" href="#1845" class="Bound">as</a><a id="1847" class="Symbol">)</a> <a id="1849" class="Symbol">=</a> <a id="1851" href="#1098" class="InductiveConstructor">here</a> <a id="1856" class="Symbol">(</a><a id="1857" href="#1845" class="Bound">as</a> <a id="1860" href="/lagda/Cubical.Data.List.Base.html#275" class="Function Operator">++</a> <a id="1863" class="Symbol">_)</a>
<a id="1866" href="#1770" class="Function">theres′</a> <a id="1874" class="Symbol">(</a><a id="1875" href="#1136" class="InductiveConstructor">there</a> <a id="1881" href="#1881" class="Bound">p</a><a id="1882" class="Symbol">)</a> <a id="1884" class="Symbol">=</a> <a id="1886" href="#1136" class="InductiveConstructor">there</a> <a id="1892" class="Symbol">(</a><a id="1893" href="#1770" class="Function">theres′</a> <a id="1901" href="#1881" class="Bound">p</a><a id="1902" class="Symbol">)</a>
</pre>
# Syntax with binding

One straightforward application of this "contains" property is "syntax with binding",
say, a syntax tree definition with binding (lambda abstraction and application)
(we're talking about simple syntax with binding here -- no HOAS/PHOAS).
We use names (say, strings) to represent references.
First, let's assume that `String` has decidable equality:

<pre class="Agda"><a id="decEqStr"></a><a id="2290" href="#2290" class="Function">decEqStr</a> <a id="2299" class="Symbol">:</a> <a id="2301" class="Symbol">(</a><a id="2302" href="#2302" class="Bound">a</a> <a id="2304" href="#2304" class="Bound">b</a> <a id="2306" class="Symbol">:</a> <a id="2308" href="/lagda/Agda.Builtin.String.html#274" class="Postulate">String</a><a id="2314" class="Symbol">)</a> <a id="2316" class="Symbol">-&gt;</a> <a id="2319" href="/lagda/Cubical.Relation.Nullary.html#391" class="Datatype">Dec</a> <a id="2323" class="Symbol">(</a><a id="2324" href="#2302" class="Bound">a</a> <a id="2326" href="/lagda/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2328" href="#2304" class="Bound">b</a><a id="2329" class="Symbol">)</a>
<a id="2331" href="#2290" class="Function">decEqStr</a> <a id="2340" href="#2340" class="Bound">a</a> <a id="2342" href="#2342" class="Bound">b</a> <a id="2344" class="Keyword">with</a> <a id="2349" href="/lagda/Agda.Builtin.String.html#462" class="Primitive">primStringEquality</a> <a id="2368" href="#2340" class="Bound">a</a> <a id="2370" href="#2342" class="Bound">b</a>
<a id="2372" class="Symbol">...</a> <a id="2376" class="Symbol">|</a> <a id="2378" href="/lagda/Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="2383" class="Symbol">=</a> <a id="2385" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="2389" href="#2407" class="Postulate">p</a> <a id="2391" class="Keyword">where</a> <a id="2397" class="Keyword">postulate</a> <a id="2407" href="#2407" class="Postulate">p</a> <a id="2409" class="Symbol">:</a> <a id="2411" class="Symbol">_</a>
<a id="2413" class="Symbol">...</a> <a id="2417" class="Symbol">|</a> <a id="2419" href="/lagda/Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="2425" class="Symbol">=</a> <a id="2427" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="2430" href="#2448" class="Postulate">p</a> <a id="2432" class="Keyword">where</a> <a id="2438" class="Keyword">postulate</a> <a id="2448" href="#2448" class="Postulate">p</a> <a id="2450" class="Symbol">:</a> <a id="2452" class="Symbol">_</a>
</pre>
The language will be typed, and will have a primitive type `nat` and the function type:

<pre class="Agda"><a id="2556" class="Keyword">infixr</a> <a id="2563" class="Number">7</a> <a id="2565" href="#2604" class="InductiveConstructor Operator">_=&gt;_</a>
<a id="2570" class="Keyword">data</a> <a id="Ty"></a><a id="2575" href="#2575" class="Datatype">Ty</a> <a id="2578" class="Symbol">:</a> <a id="2580" class="PrimitiveType">Set</a> <a id="2584" class="Keyword">where</a>
  <a id="Ty.nat"></a><a id="2592" href="#2592" class="InductiveConstructor">nat</a>  <a id="2597" class="Symbol">:</a> <a id="2599" href="#2575" class="Datatype">Ty</a>
  <a id="Ty._=&gt;_"></a><a id="2604" href="#2604" class="InductiveConstructor Operator">_=&gt;_</a> <a id="2609" class="Symbol">:</a> <a id="2611" href="#2575" class="Datatype">Ty</a> <a id="2614" class="Symbol">-&gt;</a> <a id="2617" href="#2575" class="Datatype">Ty</a> <a id="2620" class="Symbol">-&gt;</a> <a id="2623" href="#2575" class="Datatype">Ty</a>
<a id="2626" class="Keyword">variable</a> <a id="2635" href="#2635" class="Generalizable">a</a> <a id="2637" href="#2637" class="Generalizable">b</a> <a id="2639" href="#2639" class="Generalizable">c</a> <a id="2641" href="#2641" class="Generalizable">d</a> <a id="2643" class="Symbol">:</a> <a id="2645" href="#2575" class="Datatype">Ty</a>
</pre>
And equality on `Type` is decidable:

<pre class="Agda"><a id="argEq"></a><a id="2699" href="#2699" class="Function">argEq</a> <a id="2705" class="Symbol">:</a> <a id="2707" href="#2635" class="Generalizable">a</a> <a id="2709" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="2712" href="#2637" class="Generalizable">b</a> <a id="2714" href="/lagda/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2716" href="#2639" class="Generalizable">c</a> <a id="2718" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="2721" href="#2641" class="Generalizable">d</a> <a id="2723" class="Symbol">-&gt;</a> <a id="2726" class="Symbol">(</a><a id="2727" href="#2635" class="Generalizable">a</a> <a id="2729" href="/lagda/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2731" href="#2639" class="Generalizable">c</a><a id="2732" class="Symbol">)</a> <a id="2734" href="/lagda/Cubical.Data.Prod.Base.html#515" class="Datatype Operator">×</a> <a id="2736" class="Symbol">(</a><a id="2737" href="#2637" class="Generalizable">b</a> <a id="2739" href="/lagda/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2741" href="#2641" class="Generalizable">d</a><a id="2742" class="Symbol">)</a>
<a id="2744" href="#2699" class="Function">argEq</a> <a id="2750" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="2755" class="Symbol">=</a> <a id="2757" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="2762" href="/lagda/Cubical.Data.Prod.Base.html#574" class="InductiveConstructor Operator">,</a> <a id="2764" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="decEqTy"></a><a id="2770" href="#2770" class="Function">decEqTy</a> <a id="2778" class="Symbol">:</a> <a id="2780" class="Symbol">(</a><a id="2781" href="#2781" class="Bound">a</a> <a id="2783" href="#2783" class="Bound">b</a> <a id="2785" class="Symbol">:</a> <a id="2787" href="#2575" class="Datatype">Ty</a><a id="2789" class="Symbol">)</a> <a id="2791" class="Symbol">-&gt;</a> <a id="2794" href="/lagda/Cubical.Relation.Nullary.html#391" class="Datatype">Dec</a> <a id="2798" class="Symbol">(</a><a id="2799" href="#2781" class="Bound">a</a> <a id="2801" href="/lagda/Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2803" href="#2783" class="Bound">b</a><a id="2804" class="Symbol">)</a>
<a id="2806" href="#2770" class="Function">decEqTy</a> <a id="2814" href="#2592" class="InductiveConstructor">nat</a> <a id="2818" href="#2592" class="InductiveConstructor">nat</a> <a id="2822" class="Symbol">=</a> <a id="2824" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="2828" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="2833" href="#2770" class="Function">decEqTy</a> <a id="2841" href="#2592" class="InductiveConstructor">nat</a> <a id="2845" class="Symbol">(_</a> <a id="2848" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="2851" class="Symbol">_)</a> <a id="2854" class="Symbol">=</a> <a id="2856" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="2859" class="Symbol">(λ</a> <a id="2862" class="Symbol">())</a>
<a id="2866" href="#2770" class="Function">decEqTy</a> <a id="2874" class="Symbol">(</a><a id="2875" href="#2875" class="Bound">a</a> <a id="2877" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="2880" href="#2880" class="Bound">b</a><a id="2881" class="Symbol">)</a> <a id="2883" href="#2592" class="InductiveConstructor">nat</a> <a id="2887" class="Symbol">=</a> <a id="2889" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="2892" class="Symbol">(λ</a> <a id="2895" class="Symbol">())</a>
<a id="2899" href="#2770" class="Function">decEqTy</a> <a id="2907" class="Symbol">(</a><a id="2908" href="#2908" class="Bound">a</a> <a id="2910" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="2913" href="#2913" class="Bound">b</a><a id="2914" class="Symbol">)</a> <a id="2916" class="Symbol">(</a><a id="2917" href="#2917" class="Bound">c</a> <a id="2919" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="2922" href="#2922" class="Bound">d</a><a id="2923" class="Symbol">)</a> <a id="2925" class="Keyword">with</a> <a id="2930" href="#2770" class="Function">decEqTy</a> <a id="2938" href="#2908" class="Bound">a</a> <a id="2940" href="#2917" class="Bound">c</a>
<a id="2942" class="Symbol">...</a> <a id="2946" class="Symbol">|</a> <a id="2948" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="2951" href="#2951" class="Bound">nrefl</a> <a id="2957" class="Symbol">=</a> <a id="2959" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="2962" class="Symbol">(</a><a id="2963" href="#2951" class="Bound">nrefl</a> <a id="2969" href="/lagda/Cubical.Foundations.Function.html#243" class="Function Operator">∘</a> <a id="2971" href="/lagda/Cubical.Data.Prod.Base.html#609" class="Function">proj₁</a> <a id="2977" href="/lagda/Cubical.Foundations.Function.html#243" class="Function Operator">∘</a> <a id="2979" href="#2699" class="Function">argEq</a><a id="2984" class="Symbol">)</a>
<a id="2986" class="Symbol">...</a> <a id="2990" class="Symbol">|</a> <a id="2992" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="2996" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="3001" class="Keyword">with</a> <a id="3006" href="#2770" class="Function">decEqTy</a> <a id="3014" class="Bound">b</a> <a id="3016" class="Bound">d</a>
<a id="3018" class="Symbol">...</a> <a id="3022" class="Symbol">|</a> <a id="3024" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="3028" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="3033" class="Symbol">=</a> <a id="3035" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="3039" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="3044" class="Symbol">...</a> <a id="3048" class="Symbol">|</a> <a id="3050" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="3053" href="#3053" class="Bound">nrefl</a> <a id="3059" class="Symbol">=</a> <a id="3061" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="3064" class="Symbol">(</a><a id="3065" href="#3053" class="Bound">nrefl</a> <a id="3071" href="/lagda/Cubical.Foundations.Function.html#243" class="Function Operator">∘</a> <a id="3073" href="/lagda/Cubical.Data.Prod.Base.html#675" class="Function">proj₂</a> <a id="3079" href="/lagda/Cubical.Foundations.Function.html#243" class="Function Operator">∘</a> <a id="3081" href="#2699" class="Function">argEq</a><a id="3086" class="Symbol">)</a>
</pre>
Let's define `Name` as `String`, and `Ctx` (short for "Context") as a list of typed bindings
(so it's simply-typed, not dependently-typed):

<pre class="Agda"><a id="Name"></a><a id="3242" href="#3242" class="Function">Name</a> <a id="3247" class="Symbol">=</a> <a id="3249" href="/lagda/Agda.Builtin.String.html#274" class="Postulate">String</a>
<a id="Ctx"></a><a id="3256" href="#3256" class="Function">Ctx</a> <a id="3260" class="Symbol">=</a> <a id="3262" href="/lagda/Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="3267" class="Symbol">(</a><a id="3268" href="#3242" class="Function">Name</a> <a id="3273" href="/lagda/Cubical.Data.Prod.Base.html#515" class="Datatype Operator">×</a> <a id="3275" href="#2575" class="Datatype">Ty</a><a id="3277" class="Symbol">)</a>
</pre>
And here's the syntax tree definition.
Terms are required to be well-typed and well-scoped,
so it should contain the context the term is typed:

<pre class="Agda"><a id="3437" class="Keyword">data</a> <a id="Term"></a><a id="3442" href="#3442" class="Datatype">Term</a> <a id="3447" class="Symbol">(</a><a id="3448" href="#3448" class="Bound">Γ</a> <a id="3450" class="Symbol">:</a> <a id="3452" href="#3256" class="Function">Ctx</a><a id="3455" class="Symbol">)</a> <a id="3457" class="Symbol">:</a> <a id="3459" href="#2575" class="Datatype">Ty</a> <a id="3462" class="Symbol">-&gt;</a> <a id="3465" class="PrimitiveType">Set</a> <a id="3469" class="Keyword">where</a>
</pre>
`lit` creates `nat` literals and `suc` finds the successor of `nat`s,
both should be well-typed under any context:

<pre class="Agda">  <a id="Term.lit"></a><a id="3606" href="#3606" class="InductiveConstructor">lit</a> <a id="3610" class="Symbol">:</a> <a id="3612" class="Symbol">(</a><a id="3613" href="#3613" class="Bound">n</a> <a id="3615" class="Symbol">:</a> <a id="3617" href="/lagda/Agda.Builtin.Nat.html#192" class="Datatype">Nat</a><a id="3620" class="Symbol">)</a> <a id="3622" class="Symbol">-&gt;</a> <a id="3625" href="#3442" class="Datatype">Term</a> <a id="3630" href="#3448" class="Bound">Γ</a> <a id="3632" href="#2592" class="InductiveConstructor">nat</a>
  <a id="Term.suc"></a><a id="3638" href="#3638" class="InductiveConstructor">suc</a> <a id="3642" class="Symbol">:</a> <a id="3644" href="#3442" class="Datatype">Term</a> <a id="3649" href="#3448" class="Bound">Γ</a> <a id="3651" class="Symbol">(</a><a id="3652" href="#2592" class="InductiveConstructor">nat</a> <a id="3656" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="3659" href="#2592" class="InductiveConstructor">nat</a><a id="3662" class="Symbol">)</a>
</pre>
Application only happens when the function's type is respected:

<pre class="Agda">  <a id="Term.app"></a><a id="3744" href="#3744" class="InductiveConstructor">app</a> <a id="3748" class="Symbol">:</a> <a id="3750" href="#3442" class="Datatype">Term</a> <a id="3755" href="#3448" class="Bound">Γ</a> <a id="3757" class="Symbol">(</a><a id="3758" href="#2635" class="Generalizable">a</a> <a id="3760" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="3763" href="#2637" class="Generalizable">b</a><a id="3764" class="Symbol">)</a> <a id="3766" class="Symbol">-&gt;</a> <a id="3769" href="#3442" class="Datatype">Term</a> <a id="3774" href="#3448" class="Bound">Γ</a> <a id="3776" href="#2635" class="Generalizable">a</a> <a id="3778" class="Symbol">-&gt;</a> <a id="3781" href="#3442" class="Datatype">Term</a> <a id="3786" href="#3448" class="Bound">Γ</a> <a id="3788" href="#2637" class="Generalizable">b</a>
</pre>
Then let's look into bindings.
A variable reference should contain the name and a proof that the name is in-scope:

<pre class="Agda">  <a id="Term.var"></a><a id="3921" href="#3921" class="InductiveConstructor">var</a> <a id="3925" class="Symbol">:</a> <a id="3927" class="Symbol">(</a><a id="3928" href="#3928" class="Bound">x</a> <a id="3930" class="Symbol">:</a> <a id="3932" href="#3242" class="Function">Name</a><a id="3936" class="Symbol">)</a> <a id="3938" class="Symbol">(</a><a id="3939" href="#3939" class="Bound">i</a> <a id="3941" class="Symbol">:</a> <a id="3943" class="Symbol">(</a><a id="3944" href="#3928" class="Bound">x</a> <a id="3946" href="/lagda/Cubical.Data.Prod.Base.html#574" class="InductiveConstructor Operator">,</a> <a id="3948" href="#2635" class="Generalizable">a</a><a id="3949" class="Symbol">)</a> <a id="3951" href="#1052" class="Datatype Operator">∈</a> <a id="3953" href="#3448" class="Bound">Γ</a><a id="3954" class="Symbol">)</a> <a id="3956" class="Symbol">-&gt;</a> <a id="3959" href="#3442" class="Datatype">Term</a> <a id="3964" href="#3448" class="Bound">Γ</a> <a id="3966" href="#2635" class="Generalizable">a</a>
</pre>
An abstraction extends the context of the body term:

<pre class="Agda">  <a id="Term.lam"></a><a id="4037" href="#4037" class="InductiveConstructor">lam</a> <a id="4041" class="Symbol">:</a> <a id="4043" class="Symbol">(</a><a id="4044" href="#4044" class="Bound">x</a> <a id="4046" class="Symbol">:</a> <a id="4048" href="#3242" class="Function">Name</a><a id="4052" class="Symbol">)</a> <a id="4054" class="Symbol">(</a><a id="4055" href="#4055" class="Bound">a</a> <a id="4057" class="Symbol">:</a> <a id="4059" href="#2575" class="Datatype">Ty</a><a id="4061" class="Symbol">)</a> <a id="4063" class="Symbol">-&gt;</a> <a id="4066" href="#3442" class="Datatype">Term</a> <a id="4071" class="Symbol">((</a><a id="4073" href="#4044" class="Bound">x</a> <a id="4075" href="/lagda/Cubical.Data.Prod.Base.html#574" class="InductiveConstructor Operator">,</a> <a id="4077" href="#4055" class="Bound">a</a><a id="4078" class="Symbol">)</a> <a id="4080" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4082" href="#3448" class="Bound">Γ</a><a id="4083" class="Symbol">)</a> <a id="4085" href="#2637" class="Generalizable">b</a>
      <a id="4093" class="Symbol">-&gt;</a> <a id="4096" href="#3442" class="Datatype">Term</a> <a id="4101" href="#3448" class="Bound">Γ</a> <a id="4103" class="Symbol">(</a><a id="4104" href="#4055" class="Bound">a</a> <a id="4106" href="#2604" class="InductiveConstructor Operator">=&gt;</a> <a id="4109" href="#2637" class="Generalizable">b</a><a id="4110" class="Symbol">)</a>
</pre>
We don't even need to implement context lookup -- the information of the binding is already
stored in the proof term of "contains", say, in the arguments of the constructors of `∈`.

# Fact: `∈` proofs are de Bruijn indices

But what **actually** is a proof of `∈`?
The proof of `∈` is structurally isomorphic to a natural number
(`here` corresponds to `zero`, `there` corresponds to `suc`), if we omit the arguments of its constructors.
The natural number isomorphic to the proof of `∈` itself is essentially the **index** of the element
(in our case it's the binding in the context) in the list.
So what we stored in the variable references are their bindings' corresponding indices in the context!

In fact, the `lookupVar` function that tries to find a name in the context is
essentially finding the index of the name:

<pre class="Agda"><a id="lookupVar"></a><a id="4949" href="#4949" class="Function">lookupVar</a> <a id="4959" class="Symbol">:</a> <a id="4961" class="Symbol">(</a><a id="4962" href="#4962" class="Bound">Γ</a> <a id="4964" class="Symbol">:</a> <a id="4966" href="#3256" class="Function">Ctx</a><a id="4969" class="Symbol">)</a> <a id="4971" class="Symbol">(</a><a id="4972" href="#4972" class="Bound">x</a> <a id="4974" class="Symbol">:</a> <a id="4976" href="#3242" class="Function">Name</a><a id="4980" class="Symbol">)</a> <a id="4982" class="Symbol">-&gt;</a> <a id="4985" href="/lagda/Cubical.Relation.Nullary.html#391" class="Datatype">Dec</a> <a id="4989" class="Symbol">(</a><a id="4990" href="/lagda/Agda.Builtin.Sigma.html#166" class="Record">Σ</a> <a id="4992" href="#2575" class="Datatype">Ty</a> <a id="4995" class="Symbol">λ</a> <a id="4997" href="#4997" class="Bound">a</a> <a id="4999" class="Symbol">→</a> <a id="5001" class="Symbol">(</a><a id="5002" href="#4972" class="Bound">x</a> <a id="5004" href="/lagda/Cubical.Data.Prod.Base.html#574" class="InductiveConstructor Operator">,</a> <a id="5006" href="#4997" class="Bound">a</a><a id="5007" class="Symbol">)</a> <a id="5009" href="#1052" class="Datatype Operator">∈</a> <a id="5011" href="#4962" class="Bound">Γ</a><a id="5012" class="Symbol">)</a>
<a id="5014" href="#4949" class="Function">lookupVar</a> <a id="5024" href="/lagda/Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="5027" href="#5027" class="Bound">x</a> <a id="5029" class="Symbol">=</a> <a id="5031" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="5034" class="Symbol">λ</a> <a id="5036" class="Symbol">()</a>
<a id="5039" href="#4949" class="Function">lookupVar</a> <a id="5049" class="Symbol">((</a><a id="5051" href="#5051" class="Bound">y</a> <a id="5053" href="/lagda/Cubical.Data.Prod.Base.html#574" class="InductiveConstructor Operator">,</a> <a id="5055" href="#5055" class="Bound">t</a><a id="5056" class="Symbol">)</a> <a id="5058" href="/lagda/Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5060" href="#5060" class="Bound">Γ</a><a id="5061" class="Symbol">)</a> <a id="5063" href="#5063" class="Bound">x</a> <a id="5065" class="Keyword">with</a> <a id="5070" href="#2290" class="Function">decEqStr</a> <a id="5079" href="#5063" class="Bound">x</a> <a id="5081" href="#5051" class="Bound">y</a>
<a id="5083" class="Symbol">...</a> <a id="5087" class="Symbol">|</a> <a id="5089" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="5093" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="5098" class="Symbol">=</a> <a id="5100" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="5104" class="Symbol">(</a><a id="5105" class="Bound">t</a> <a id="5107" href="/lagda/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5109" href="#1098" class="InductiveConstructor">here</a> <a id="5114" class="Bound">Γ</a><a id="5115" class="Symbol">)</a> <a id="5117" class="Comment">-- return `zero`</a>
<a id="5134" class="Symbol">...</a> <a id="5138" class="Symbol">|</a> <a id="5140" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="5143" href="#5143" class="Bound">nrefl</a> <a id="5149" class="Keyword">with</a> <a id="5154" href="#4949" class="Function">lookupVar</a> <a id="5164" class="Bound">Γ</a> <a id="5166" class="Bound">x</a>
<a id="5168" class="Symbol">...</a> <a id="5172" class="Symbol">|</a> <a id="5174" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="5177" href="#5177" class="Bound">nex</a> <a id="5181" class="Symbol">=</a> <a id="5183" href="/lagda/Cubical.Relation.Nullary.html#452" class="InductiveConstructor">no</a> <a id="5186" class="Symbol">λ</a>
  <a id="5190" class="Symbol">{</a> <a id="5192" class="Symbol">(</a><a id="5193" href="#5193" class="Bound">s</a> <a id="5195" href="/lagda/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5197" href="#1098" class="InductiveConstructor">here</a> <a id="5202" class="DottedPattern Symbol">.</a><a id="5203" class="DottedPattern Bound">Γ</a><a id="5204" class="Symbol">)</a> <a id="5206" class="Symbol">-&gt;</a> <a id="5209" class="Bound">nrefl</a> <a id="5215" href="/lagda/Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
  <a id="5222" class="Symbol">;</a> <a id="5224" class="Symbol">(</a><a id="5225" href="#5225" class="Bound">s</a> <a id="5227" href="/lagda/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5229" href="#1136" class="InductiveConstructor">there</a> <a id="5235" href="#5235" class="Bound">p</a><a id="5236" class="Symbol">)</a> <a id="5238" class="Symbol">-&gt;</a> <a id="5241" href="#5177" class="Bound">nex</a> <a id="5245" class="Symbol">(</a><a id="5246" href="#5225" class="Bound">s</a> <a id="5248" href="/lagda/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5250" href="#5235" class="Bound">p</a><a id="5251" class="Symbol">)</a>
  <a id="5255" class="Symbol">}</a>
<a id="5257" class="Symbol">...</a> <a id="5261" class="Symbol">|</a> <a id="5263" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="5267" href="#5267" class="Bound">ex</a> <a id="5270" class="Symbol">=</a> <a id="5272" href="/lagda/Cubical.Relation.Nullary.html#425" class="InductiveConstructor">yes</a> <a id="5276" class="Symbol">(</a><a id="5277" href="#5267" class="Bound">ex</a> <a id="5280" class="Symbol">.</a><a id="5281" href="/lagda/Agda.Builtin.Sigma.html#252" class="Field">fst</a> <a id="5285" href="/lagda/Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5287" href="#1136" class="InductiveConstructor">there</a> <a id="5293" class="Symbol">(</a><a id="5294" href="#5267" class="Bound">ex</a> <a id="5297" class="Symbol">.</a><a id="5298" href="/lagda/Agda.Builtin.Sigma.html#264" class="Field">snd</a><a id="5301" class="Symbol">))</a>
          <a id="5314" class="Comment">-- ^ return `suc &lt;induction result&gt;`</a>
</pre>
An interesting fact is that it is enough to store only the index of the binding in
variable reference terms.
The indices we're using here is also known as **De Bruijn Indices**.

Note: we'll need to really lookup the context to obtain the type of a binding if the constructor arguments
of `∈`'s proof are omitted, though.

# Remark: terms from different contexts

In our setting, terms are bounded with the context they are formed under.
This means that when we want to, say, do some term substitution,
(so two terms go together into one)
we need to ensure the terms are from the same context.

Example: apply a term `e` onto a lambda term `f` requires `e` and `f` to be formed
under the same context (this fact can be told from the parameters of `Term.app`).
Imagine `f` is of form `λ x. a` where `a` is a term, we can tell from the parameters
of `Term.lam` that `a` is formed under a context extended from the context where `f`
and `e` are formed. Therefore we cannot simply substitute `x := e` into `a`,
because `a` and `e` are from different contexts.
This implies that we need to append `x` into the context of `e`
before substitution, say, plus one to all the indices inside `e`
(we refer to this operation as "shifting" or "weakening").

In fact, we can extend the context with any arbitrary contexts:

<pre class="Agda"><a id="extendCtx"></a><a id="6674" href="#6674" class="Function">extendCtx</a> <a id="6684" class="Symbol">:</a> <a id="6686" class="Symbol">∀</a> <a id="6688" class="Symbol">{</a><a id="6689" href="#6689" class="Bound">Γ</a> <a id="6691" href="#6691" class="Bound">Θ</a> <a id="6693" href="#6693" class="Bound">a</a><a id="6694" class="Symbol">}</a> <a id="6696" class="Symbol">-&gt;</a> <a id="6699" href="#3442" class="Datatype">Term</a> <a id="6704" href="#6689" class="Bound">Γ</a> <a id="6706" href="#6693" class="Bound">a</a> <a id="6708" class="Symbol">-&gt;</a> <a id="6711" href="#3442" class="Datatype">Term</a> <a id="6716" class="Symbol">(</a><a id="6717" href="#6689" class="Bound">Γ</a> <a id="6719" href="/lagda/Cubical.Data.List.Base.html#275" class="Function Operator">++</a> <a id="6722" href="#6691" class="Bound">Θ</a><a id="6723" class="Symbol">)</a> <a id="6725" href="#6693" class="Bound">a</a>
<a id="6727" href="#6674" class="Function">extendCtx</a> <a id="6737" class="Symbol">(</a><a id="6738" href="#3606" class="InductiveConstructor">lit</a> <a id="6742" href="#6742" class="Bound">n</a><a id="6743" class="Symbol">)</a> <a id="6745" class="Symbol">=</a> <a id="6747" href="#3606" class="InductiveConstructor">lit</a> <a id="6751" href="#6742" class="Bound">n</a>
<a id="6753" href="#6674" class="Function">extendCtx</a> <a id="6763" href="#3638" class="InductiveConstructor">suc</a> <a id="6767" class="Symbol">=</a> <a id="6769" href="#3638" class="InductiveConstructor">suc</a>
<a id="6773" href="#6674" class="Function">extendCtx</a> <a id="6783" class="Symbol">(</a><a id="6784" href="#3744" class="InductiveConstructor">app</a> <a id="6788" href="#6788" class="Bound">f</a> <a id="6790" href="#6790" class="Bound">e</a><a id="6791" class="Symbol">)</a> <a id="6793" class="Symbol">=</a> <a id="6795" href="#3744" class="InductiveConstructor">app</a> <a id="6799" class="Symbol">(</a><a id="6800" href="#6674" class="Function">extendCtx</a> <a id="6810" href="#6788" class="Bound">f</a><a id="6811" class="Symbol">)</a> <a id="6813" class="Symbol">(</a><a id="6814" href="#6674" class="Function">extendCtx</a> <a id="6824" href="#6790" class="Bound">e</a><a id="6825" class="Symbol">)</a>
<a id="6827" href="#6674" class="Function">extendCtx</a> <a id="6837" class="Symbol">(</a><a id="6838" href="#3921" class="InductiveConstructor">var</a> <a id="6842" href="#6842" class="Bound">x</a> <a id="6844" href="#6844" class="Bound">i</a><a id="6845" class="Symbol">)</a> <a id="6847" class="Symbol">=</a> <a id="6849" href="#3921" class="InductiveConstructor">var</a> <a id="6853" href="#6842" class="Bound">x</a> <a id="6855" class="Symbol">(</a><a id="6856" href="#1770" class="Function">theres′</a> <a id="6864" href="#6844" class="Bound">i</a><a id="6865" class="Symbol">)</a>
<a id="6867" href="#6674" class="Function">extendCtx</a> <a id="6877" class="Symbol">(</a><a id="6878" href="#4037" class="InductiveConstructor">lam</a> <a id="6882" href="#6882" class="Bound">x</a> <a id="6884" href="#6884" class="Bound">a</a> <a id="6886" href="#6886" class="Bound">p</a><a id="6887" class="Symbol">)</a> <a id="6889" class="Symbol">=</a> <a id="6891" href="#4037" class="InductiveConstructor">lam</a> <a id="6895" href="#6882" class="Bound">x</a> <a id="6897" href="#6884" class="Bound">a</a> <a id="6899" class="Symbol">(</a><a id="6900" href="#6674" class="Function">extendCtx</a> <a id="6910" href="#6886" class="Bound">p</a><a id="6911" class="Symbol">)</a>
</pre>
Note that this `extendCtx` doesn't touch the name of the variables.
The variable references still refer to correct binding even there's name shadowing.

There's a common mistake for those who try to implement syntax with binding
via de Bruijn indices, say, forgetting to shift the indices of the substituted term.
Now with dependent types, we gain a thorough understanding of why should we shift
the indices before substitution.
The same thing also happens for "taking a binding from the context"
when dealing with let bindings or typed bindings under dependent types --
the bindings themselves are from a different (though weaker, because they're from a
outer scope with fewer variables) context, so we need to shift them before
using them under the inner contexts.

I have jumped into the hole of "forgetting to shift de Bruijn indices" when
developing [Voile] and [Narc]. That's also the motivation for writing this post.
I hope this will help dependent type implementors.

 [Voile]: https://lib.rs/voile
 [Narc]:  https://lib.rs/nar

