---
layout: post
title: Arend 组面试
description: Arend team interview
permalink: /interview/jetbrains-arend.html
katex: true
---


入职后的更新：

0. 最后的作业被面试官找到了些 bug，不过最终还是顺利完成了，在
   [这里](/pages/vitalyr-normalizer) 有个说明文档，代码实现可以在
   [这里](https://github.com/owo-lang/intellij-dtlc/blob/master/src/org/ice1000/tt/editing/vitalyr/normalize.kt) 找到。
   0. 编程语言的名字用了我的朋友的网名，当事人是数学大佬。
0. Higher Coinductive Type 在去掉 guardedness 和 negativity 后剩下的核心的、
   比普通的 Coinductive Type 多出的功能就是 field (projection) 的 path constraints。
   这个在 Arend 里面已经有了，有 record with conditions。其中 `Path` 就是一个这样的类型
   （而不是一个语言内建的类型——当然 Arend 还是把 Path 做成了 intrinsic 的）。
0. 面试通过后，面试官变成了我的 mentor——和 PingCAP 时一样。
0. 我又问了一个新的问题——为什么 JetBrains 要做 Arend？这又没有利益可寻。
   0. mentor 说：JetBrains Research 的项目都是这样的。这些东西可能未来会有用。
      开启这样的项目并不容易，只有 Sergey Dmitriev 那个级别的人才做得到。
   0. 我问：我们开发 Arend 的目的是什么？
   0. mentor 说：最大的目标是形式化所有的数学。但是这需要时间。我想从基本的部分开始，
      比如基础代数、拓扑学、分析学，等等。搞这些证明很难不用 tactics，
      所以我在这个版本开始支持 tactics。
   0. 我追问：现在有很多定理证明器，为什么不去用其他的？
   0. mentor 说：这些系统都有他们自己的缺陷，我们想在 Arend 里面解决这些缺陷。
0. 我们又讨论了下形式化数学本身。mentor 说，HoTT 基本上就是为了让我们能在类型论里面更
   “普通地” 做数学。比如你必须有 quotient，而其他类型论没有。
   mentor 指出，我们在形式化一个代数结构的时候（比如 $\mathbb{Q}$），形式化的不仅仅是它的定义，
   还有它上面的操作。$\mathbb{Q}$ 本身很好定义，但是证明它是一个域却比它的结构本身复杂的多
   （虽然 $\mathbb{Q}$ 的操作也算是很好定义的了。反正我们得定义它）。
0. 工作一切顺利，在我在职期间发布了 1.3.0 版本，其中有几个复杂的 IDE 功能是我做的。
   在接下来的版本中我可能会做点语法糖什么的（其实已经做好了……只是我是在 feature freeze
   阶段做的，所以得等下个版本再上线）。
0. 吐槽一下：同事是真的不会用 Gradle 啊……

更新结束，下面是原文。

这算是个新鲜出炉的面经，因为我现在还不知道能不能拿到 offer。
面试官是 Arend 编译器的（唯一）维护者，通过网络电话面试。
一股浓浓的俄罗斯口音。我听着挺吃力的，但是基本上交流没问题，毕竟我也有中文口音也不好说什么哈哈。

首先让我介绍了自己的经历。我讲述了我从 Haskell 入坑函数式编程，到后来入坑类型论，转而以 model mathematics 为目标做 PL 研究，以及期间给 Agda 的编译器和库贡献代码之类的二三事。
我同时指出我很重视类型论的实现，面试官好像挺看重这个。

# 问题

0. 给定 Haskell 代码 `fact 100000 + fact 100000`，问 `fact` 被执行了几次。
   0. 回答：2 乘以内部递归次数。不考虑递归的话就是 2 次。
   0. 分析：可能是考察我对惰性求值的一些细节的理解。嘛反正和工作内容没啥关系就是了。
0. 给定 Haskell 代码 `min xs = head (qsort xs)` 然后 `qsort` 是你能在网上找到的那个 `qsort`，问这个 `min` 的时间复杂度是多少。
   0. 回答：$\log{n}$，在面试官提示下我还说“复杂度不稳定，最坏是 $n$”。
   0. 分析：这个我回答错了，实际上就是 $n$ 常数。
      惰性快排求前 k 项的复杂度是 $n+k\log{n}$，
      然后 $\log{n}$ 就是那个可能会因为输入的形状而退化成 $n$ 的部分。
   0. 依然是考察惰性求值，我已经很多年没有研究过惰性求值的行为了，突然给我一个相对于前面那个问题来说比较复杂的函数，我也没反应过来，面试官也没直说我答错了。
      算是一个扣分点，希望面试官手下留情。
0. 如何证明 `State` 是一个 Monad？
   0. 回答：取决于你如何定义带性质的 Monad，因为各种定义都比较常见。
      我举出了 Agda 标准库使用的 Indexed Monad，然后说 `State` 就实例化各个 field，然后用 Eq-Reasoning 那套组合子去证明呗。
   0. 我指出证明可能会很长，但面试官纠正了我——我忘记了 `State` 就是一个返回两个值的函数，其实这个性质是很平凡的（太久没摸 Haskell 又栽坑里了，哭泣）。
0. 给定一个局部环（我跟面试官说我的抽代课还没学到这里，他就解释说你可以想象成一个环，
   满足$\forall x.\exists y.(y=x^{-1}\vee y=(1-x)^{-1})$这一性质），其中$0\neq 1$，证明幂等只有两个。
   0. 面试官考虑到我还没学到这些东西，问完问题就放弃了。
0. 让你在 dependent-type 中写一个排序算法，你会选择哪个？
   0. 回答（没经过思考，口胡中）：归并排序吧，毕竟快排好写但它不是结构归纳啊。
   0. 追问：可是归并排序也不是结构归纳啊。
   0. 回答（汗如雨下）：呃……这么一说三个复杂度最好的排序都不是结构归纳啊！
      那不考虑复杂度的话我就选插入排序吧，这个的 Sorted List 性质最好证明，也是结构归纳的。
   0. 追问：那如果你要写快排，如何证明它停机呢（这在我看来是一个非常好的追问）？
   0. 回答：在 Agda 中我们可以使用 Sized Types，给类型加上一些注解来给编译器提供额外的、不明显的数据的大小信息，这样就可以让非结构归纳也停机了。
      其次，我们可以使用 Well-Founded Induction 库，不改变类型而是改变程序来证明停机。
      再者，我们可以给函数加一个 `Nat` 参数，每做一次归纳就让 `Nat` 减一，当 `Nat` 为 0 的时候直接返回，然后我们知道 `Nat` 为 0 的时候要么是 unreachable 的，要么和 base case 相同。

# 面试官随后问了我

0. 对于 Idris 有什么看法？
   0. 回答：coinduction 的 η-conversion 实现的太憨批（被打断）
0. （插嘴）你为什么这么重视 Coinduction，到底哪里有用了？
   0. 回答：我其实是为了用而用，毕竟我觉得这个特性很有意思，能表达无穷大的自然数，或者无限的序列。
   0. 面试官指出 Path 其实就是 Bisimulation，我表示我已经知道这一点。
   0. 我还向面试官指出了 Cubical Agda 在这方面的特殊支持，面试官之前可能也不知道哈哈。
   0. 我还说可能可以做 Higher Coinductive Types（完全没 research 啊，大宝藏），面试官没理我。
      回头再逮着他问。
0. 对于 Agda 有什么看法？
   0. 回答：虽然很垃圾，但是其他的都更垃圾，导致 Agda 是唯一能用的。而且 Agda 功能很全，我喜欢这一点
0. 你最喜欢的编程语言是什么？
   0. 回答了 Agda，Perl，Kotlin，Rust，理由的话我倒是解释了，但是考虑到熟悉我的人应该都知道我就不说了。
      面试官当场喷 Kotlin，说语言好但是 IDE 太慢了，支持的也不全。我没法反驳……
0. 你对于参与开发的子项目有什么偏好吗？比如“我不想做 UI”之类的？
   0. 回答：不想做 UI（立即复读，面试官笑了哈哈），插件可以接受但是更倾向于编译器和标准库，优先编译器
0. 谈谈你对直觉主义逻辑的看法。
   0. 回答：与其说它失去了经典逻辑的一些力量，不如说它对经典逻辑进行了一些纠正（即使我并不认为经典逻辑是错的）。
      但是构造主义逻辑给计算机带来了验证证明和生成证明的能力，就说明了它的价值。
0. 谈谈你最喜欢的一个个人项目。
   0. 回答：我首先指出我参与了很多别人的项目。
      然后我目前最喜欢的应该就是 Voile 了呀，我说这是一个 row-polymorphic 的 dependent-type 语言，
      我设计了一套 core language 给 row-term。面试官找我要论文并答应不外传，我就发给他了
0. 还问了我会多少数学，问到了范畴论和实数。
   0. 我就回答的很坦诚，说我不会 HoTT，但是会 CTT 和 MLTT，不会范畴论但是短期内就准备学习。
      在这之下的抽象袋鼠我是非常自信的
   0. 说到实数我是真的暴风哭泣了。我说我知道有戴德金分割和柯西序列，但是两个我都没写过也没看过别人写的。
      0. 面试官追问：那你能不能说说你对实数的认识？比如学校里讲的那个也可以，不一定要构造定义的。
      0. 我就只能口胡，给面试官讲了实数轴。
      0. 面试官说：事实上我们大部分时候在用实数来定义实数轴而不是反过来。能不能来点给劲的。
      0. 我实在没办法了，就只能进一步口胡：首先不考虑任何几何的东西，那么实数应该可以看作是有理数加上根号运算。
         面试官没有追问了，估计是对我的数学水平无语了 😶。
0. 什么是 Monad？
   0. 听到问题我直接笑了。面试官也笑了。
   0. 回答：取决于是什么样的人问我。
      0. 如果对方是一个工程师，我就会说是“可编程的分号”。
      0. 如果不是的话，我就会用梗来回答。
      0. 面试官笑了，并说其实我们不是那么想的。我辩解道这很难口头解释，面试官也就没有多问了

# 我的问题

我还问了面试官非常非常多的问题，面试官都很认真地回答了哈哈。

中途我还问了他的名字在俄语里面怎么念，以及其他几个组员的名字在俄语里面怎么念。
他非常含糊地回答了我，可能是怕我觉得奇怪吧，但是我很喜欢研究这种事儿哈哈。

0. 你们拿 protobuf 干啥嘞，该不会是给 IDE 传数据吧？
   0. 回答：序列化 core term 啊，就是那个 arc 后缀的文件。我们是不会做其他 IDE 的支持的
0. 有没有想过整一个和 IntelliJ-Rust 一样的工作流，有 nightly channel，支持最新的两个 release，支持 EAP，分版本存一些 codebase？
   0. 回答：还没想过这个问题，不过觉得挺好的
0. 有什么设计上参考了 Cubical Agda 的地方吗？
   0. 回答：没有。我们的模型 5 年前就有了（注：CCHM 是 2016 年的，今年是 2019），当时的想法就是让 HoTT 能计算。几个人在想同样的事情，一拍即合就开干了。
   0. 我追问了一些问题，关于实现的（η-rule，以及 `coe iso` 是怎么计算的）。
      面试官都一一回答，我们两个都在 IDE 里面开着 Arend 的编译器哈哈，马上就能 navigate 到，很棒。
   0. 顺带一提，`coe iso` 的计算在 `NormalizeVisitor` 里面。
0. Arend 组的人都有谁，都在干啥，团队合作用啥工具？
   0. 面试官回答了。但是我就不写出来给你们看了，觉得这样不好
0. 这个面向反斜杠编程的语法就是最终语法了吗，还说说只是一个 placeholder？
   0. 回答：就是最终语法。它看起来很奇怪，但是我喜欢
   0. 我说我也很喜欢哈哈，毕竟你想要一个关键字的时候按 backslash 就好了
0. 文学编程上有什么想法吗，比如 lagda 那样的？
   0. 我给面试官看了我的 lagda 博客。
   0. 回答：对于写 LaTeX，应该有比 lagda 更好的解决方案。
   0. 对于 HTML，觉得不重要，以后再说吧
0. HIT 的 pattern-match 不是要 respect path constructor 吗，
    Agda 会显示 constraints，Arend 是怎么处理的？
   0. 回答：还没做呢，但是很想做这个，而且已经知道怎么实现了，就差把它写出来了！
0. 做 codegen/backend 吗？比如编译到 Java。
   0. 回答：有个需要在这之前解决的问题，就是 stuck term 怎么计算。
      Arend 没有 canonicity。但是这个解决了就都好说。这个觉得也不重要，以后再说
0. 社区建设有什么想法吗？
   0. 回答：有啊，我整了 Google Groups 和 Twitter 官方号呢
   0. 追问：那个 Twitter 号就是你运营的（因为之前和这个号对话过）？
   0. 回答（笑）：是的
   0. 我表示可以在这方面帮忙，我还推荐了 Gitter，说是和 GitHub 高度集成。
      面试官说这是个需要时间的事儿，我表示深刻理解。
0. 最近准备开发什么特性/修什么 bug？
   0. 回答：做个 scala-worksheet 那样的 in-IDE 的 REPL
0. 库和包管理有什么想法吗
   0. 回答：我们还没什么库呢，以后再说吧
0. 我看你测试里面有好多被注释了的，都是些干啥的？
   0. 回答：一些被丢弃的功能。可能以后会重新做，也可能不做了
0. 准备迁移到 Kotlin 吗？
   0. 回答：不准备。
   0. 灵魂追问：那如果我要迁移到 Kotlin，你会阻止我吗？
   0. 面试官笑着回答：会。
0. 追问：那也可以考虑用用 JB Annotations，至少能解决 null-safe 的问题。
   0. 面试官：其实已经在用了，用的不多而已
      0. 不过我觉得他在诓我，我连依赖都没看到（逃）
0. CPT 和工资呢？面试官说等面试通过了会有人和你谈。

最后给了我一个作业，没给时间限制，让我尽可能做。
大概是在 IntelliJ 里面写一个 untyped lambda calculus，然后要支持它的 normalization。
遇到 non-terminating 的 term 要防止死循环，也就意味着我不能直接 eval。
面试官指出“你必须允许 general recursion”。

我想这还不简单嘛，马上做给你看。
